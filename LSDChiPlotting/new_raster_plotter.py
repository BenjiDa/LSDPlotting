## raster_plotter.py
##=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
## Function to plot the raster data in *.flt format generated by the 
## chi analysis code. read_flt() returns flt data as numpy arrays and is 
## called by the plot_ChiMValues_hillshade() to quickly visualise the 
## m values without launching arcmap. Vectorize() plots the m values
## as individual points. Next step may be to thin the points?
##
## flt reading Built around code from http://pydoc.net/Python/PyTOPKAPI/0.2.0/pytopkapi.arcfltgrid/
##=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
## SWDG 19/06/2013
## modified SMM 09/08/2013
## modified SMM 12/02/2016
##=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# you need to have the LSDPlotting folder in your directory. 
# find it here: https://github.com/LSDtopotools/LSDMappingTools
import LSDPlottingTools as LSDP



def coloured_chans_like_graphs(hillshade_file, tree_file):
    """
    Plots outlines of channels taken from the *.tree file over a hillshade
    giving each channel a unique colour which corresponds to the colours used
    in the Chi plotting routines in chi_visualisation.py.
    
    """
 
    label_size = 20
    #title_size = 30
    axis_size = 28

    
   
    import matplotlib.pyplot as pp
    import numpy as np
    import matplotlib.colors as colors
    import matplotlib.cm as cmx
    from matplotlib import rcParams
    import matplotlib.lines as mpllines
    
    # make sure the nodata is formatted
    LSDP.CheckNoData(hillshade_file)    
    
    #get data
    hillshade = LSDP.ReadRasterArrayBlocks(hillshade_file)
    
    #ignore nodata values    
    hillshade = np.ma.masked_where(hillshade == -9999, hillshade)    

    # now get the extent
    extent_raster = LSDP.GetRasterExtent(hillshade_file)
    
    x_min = extent_raster[0]
    x_max = extent_raster[1]
    y_min = extent_raster[2]
    y_max = extent_raster[3]

    
    #fonts
    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = ['arial']
    rcParams['font.size'] = label_size  

    #get coordinates of streams from tree file   
    channel_id = []
    row = []
    col = []
        
    with open(tree_file, 'r') as f:
        lines = f.readlines()
        
    for q,line in enumerate(lines):
        if q > 0: #skip first line
            channel_id.append(int(line.split()[0]))
            row.append(float(line.split()[4]))
            col.append(float(line.split()[5]))

    #get bounding box & pad to 10% of the dimension
    x_max = max(col)
    x_min = min(col)
    y_max = max(row)
    y_min = min(row) 
    
    pad_x = (x_max - x_min) * 0.1
    pad_y = (x_max - y_min) * 0.1
    
    if (pad_y > pad_x):
        pad_x = pad_y
    else:
        pad_y = pad_x
    
    x_max += pad_x
    x_min -= pad_x
    y_max += pad_y
    y_min -= pad_y 
    
    fig = pp.figure(1, facecolor='white',figsize=(10,7.5))
    ax = fig.add_subplot(1,1,1)
    ax.imshow(hillshade, vmin=0, vmax=255, cmap=cmx.gray)
    

    # now get the tick marks 
    n_target_tics = 5
    xlocs,ylocs,new_x_labels,new_y_labels = LSDP.GetTicksForUTM(hillshade_file,x_max,x_min,y_max,y_min,n_target_tics)  

    pp.xticks(xlocs, new_x_labels, rotation=60)  #[1:-1] skips ticks where we have no data
    pp.yticks(ylocs, new_y_labels) 
    


    # some formatting to make some of the ticks point outward    
    for line in ax.get_xticklines():
        line.set_marker(mpllines.TICKDOWN)
        #line.set_markeredgewidth(3)

    for line in ax.get_yticklines():
        line.set_marker(mpllines.TICKLEFT)
        #line.set_markeredgewidth(3)  
    
    pp.xlim(x_min,x_max)    
    pp.ylim(y_max,y_min)   
   
    pp.xlabel('Easting (m)',fontsize = axis_size)
    pp.ylabel('Northing (m)', fontsize = axis_size)  
                  
    # channel ID
    Channel_ID_MIN = np.min(channel_id)
    Channel_ID_MAX = np.max(channel_id)
    cNorm_channel_ID  = colors.Normalize(vmin=Channel_ID_MIN, vmax=Channel_ID_MAX)  # the max number of channel segs is the 'top' colour
    jet = pp.get_cmap('jet')
    scalarMap_channel_ID = cmx.ScalarMappable(norm=cNorm_channel_ID, cmap=jet) 
    

    #for a,i in enumerate(reversed(channel_id)):
    for a,i in enumerate(channel_id):
        if i != 0:
            # plot other stream segments
            colorVal = scalarMap_channel_ID.to_rgba(i) # this gets the distinct colour for this segment
            pp.scatter(col[a], row[a], 30,marker=".", color=colorVal,edgecolors='none') 

    for a,i in enumerate(channel_id):
        if i == 0:
            # plot trunk stream in black
            pp.scatter(col[a], row[a], 40,marker=".", color='k',edgecolors='none')
 
    ax.spines['top'].set_linewidth(2.5)
    ax.spines['left'].set_linewidth(2.5)
    ax.spines['right'].set_linewidth(2.5)
    ax.spines['bottom'].set_linewidth(2.5) 
    ax.tick_params(axis='both', width=2.5)     
 
    pp.xlim(x_min,x_max)    
    pp.ylim(y_max,y_min) 
 
    pp.title("Channels colored by channel number",fontsize=label_size)  
    pp.tight_layout()        

    
    
    pp.show()
    
    
    
    
    
def m_values_over_hillshade(hillshade_file, tree_file):
    """
    Plots m values of channels taken from the *.tree file over a hillshade
    
    """
 
    label_size = 20
    #title_size = 30
    axis_size = 28
   
    import matplotlib.pyplot as pp
    import numpy as np
    import matplotlib.colors as colors
    import matplotlib.cm as cmx
    from matplotlib import rcParams
    import matplotlib.lines as mpllines
    
    #get data
    hillshade = LSDP.ReadRasterArrayBlocks(hillshade_file)
    
    #ignore nodata values    
    hillshade = np.ma.masked_where(hillshade == -9999, hillshade)    

    # now get the extent
    extent_raster = LSDP.GetRasterExtent(hillshade_file)
    
    x_min = extent_raster[0]
    x_max = extent_raster[1]
    y_min = extent_raster[2]
    y_max = extent_raster[3]
    
    #ignore nodata values    
    hillshade = np.ma.masked_where(hillshade == -9999, hillshade)    
    
    #fonts
    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = ['arial']
    rcParams['font.size'] = label_size  

    #get coordinates of streams from tree file   
    M_chi_value = []
    channel_id = []
    row = []
    col = []
        
    with open(tree_file, 'r') as f:
        lines = f.readlines()
        
    for q,line in enumerate(lines):
        if q > 0: #skip first line
            channel_id.append(float(line.split()[0]))
            M_chi_value.append(float(line.split()[11]))
            row.append(float(line.split()[4]))
            col.append(float(line.split()[5]))

    #get bounding box & pad to 10% of the dimension
    x_max = max(col)
    x_min = min(col)
    y_max = max(row)
    y_min = min(row) 
    
    pad_x = (x_max - x_min) * 0.1
    pad_y = (x_max - y_min) * 0.1
    
    if (pad_y > pad_x):
        pad_x = pad_y
    else:
        pad_y = pad_x
    
    x_max += pad_x
    x_min -= pad_x
    y_max += pad_y
    y_min -= pad_y 
    
    fig = pp.figure(1, facecolor='white',figsize=(10,7.5))
    ax = fig.add_subplot(1,1,1)
    ax.imshow(hillshade, vmin=0, vmax=255, cmap=cmx.gray)
    
    # now get the tick marks 
    n_target_tics = 5
    xlocs,ylocs,new_x_labels,new_y_labels = LSDP.GetTicksForUTM(hillshade_file,x_max,x_min,y_max,y_min,n_target_tics)  

    pp.xticks(xlocs, new_x_labels, rotation=60)  #[1:-1] skips ticks where we have no data
    pp.yticks(ylocs, new_y_labels) 
    
    for line in ax.get_xticklines():
        line.set_marker(mpllines.TICKDOWN)
        #line.set_markeredgewidth(3)

    for line in ax.get_yticklines():
        line.set_marker(mpllines.TICKLEFT)
        #line.set_markeredgewidth(3)  
 
    pp.xlim(x_min,x_max)    
    pp.ylim(y_max,y_min)  
   
    pp.xlabel('Easting (m)',fontsize = axis_size)
    pp.ylabel('Northing (m)',fontsize = axis_size)    
              
    # channel ID
    M_chi_value_MIN = np.min(M_chi_value)
    M_chi_value_MAX = np.max(M_chi_value)
    cNorm_M_chi_value  = colors.Normalize(vmin=M_chi_value_MIN, vmax=M_chi_value_MAX)  # the max number of channel segs is the 'top' colour
    hot = pp.get_cmap('RdYlBu_r')
    scalarMap_M_chi_value = cmx.ScalarMappable(norm=cNorm_M_chi_value, cmap=hot) 
    
    
    for a,i in enumerate(M_chi_value):
        #print "a: " +str(a)+" i: " +str(i)
        if channel_id[a] != 0:     
            # plot other stream segments
            colorVal = scalarMap_M_chi_value.to_rgba(i) # this gets the distinct colour for this segment
            pp.scatter(col[a], row[a], 30,marker=".", color=colorVal,edgecolors=colorVal) 

    for a,i in enumerate(M_chi_value):
        if channel_id[a] == 0:
            # plot trunk stream in black
            colorVal = scalarMap_M_chi_value.to_rgba(i)
            pp.scatter(col[a], row[a], 40,marker=".", color=colorVal,edgecolors=colorVal)

    sm = pp.cm.ScalarMappable(cmap=hot, norm=pp.normalize(vmin=min(M_chi_value), vmax=max(M_chi_value)))
    sm._A = []
    


    
    ax.spines['top'].set_linewidth(2.5)
    ax.spines['left'].set_linewidth(2.5)
    ax.spines['right'].set_linewidth(2.5)
    ax.spines['bottom'].set_linewidth(2.5) 
    ax.tick_params(axis='both', width=2.5)      
    
    from mpl_toolkits.axes_grid1 import make_axes_locatable
    divider = make_axes_locatable(pp.gca())
    cax = divider.append_axes("right", "5%", pad="3%")
    pp.colorbar(sm, cax=cax).set_label('$M_{\chi}$',fontsize=axis_size) 
    cax.tick_params(labelsize=label_size) 
    
    #pp.xlim(x_min,x_max)    
    #pp.ylim(y_max,y_min) 

    pp.tight_layout()
        
    pp.show()


#coloured_chans_like_graphs('M:\\students\\kunkelova\\bk_10m_dem_HS.bil', 'M:\\students\\kunkelova\\bk_10m_dem_fullProfileMC_forced_0.45_20_3_14_90_130.tree')   
m_values_over_hillshade('M:\\students\\kunkelova\\bk_10m_dem_HS.bil', 'M:\\students\\kunkelova\\bk_10m_dem_fullProfileMC_forced_0.45_20_3_14_90_130.tree') 
#plot_ChiMValues_hillshade('M:\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'M:\\LSDRaster_chi_package\\Test_data\\rio_torto_ChiMValues_115.flt')
#vectorize('S:\\PA\\pa_basin_HS.flt', 'S:\\PA\\pa_basin_ChiMValues_1189.flt')
#coloured_chans_like_graphs('S:\\PA\\pa_basin_HS.flt', 'S:\\PA\\pa_basin_fullProfileMC_mainstem_1189.tree')
#coloured_chans_like_graphs('c:\\code\\topographic_analysis\\LSDRaster_chi_package\\PA\\pa_basin_HS.flt', 'c:\\users\\smudd\\Documents\\topographic_analysis\\LSDRaster_chi_package\\PA\\pa_basin_fullProfileMC_mainstem_1189.tree')
#m_values_over_hillshade('S:\\PA\\pa_basin_HS.flt', 'S:\\PA\\pa_basin_fullProfileMC_mainstem_1189.tree')
#m_values_over_hillshade('c:\\code\\topographic_analysis\\LSDRaster_chi_package\\PA\\pa_basin_HS.flt', 'c:\\users\\smudd\\Documents\\topographic_analysis\\LSDRaster_chi_package\\PA\\pa_basin_fullProfileMC_mainstem_1189.tree')
#m_values_over_hillshade('c:\\code\\topographic_analysis\\LSDRaster_chi_package\\PA\\pa_basin_HS.flt', 'c:\\users\\smudd\\Documents\\topographic_analysis\\LSDRaster_chi_package\\PA\\pa_basin_fullProfileMC_mainstem_445.tree')
#coloured_chans_like_graphs('M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_forced_0.8_634.tree')
#m_values_over_hillshade('M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_forced_0.8_634.tree')
#m_values_over_hillshade('M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_mainstem_633.tree')
#m_values_over_hillshade('M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_mainstem_114.tree')
#coloured_chans_like_graphs('M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'M:\\topographic_tools\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_mainstem_114.tree')
#coloured_chans_like_graphs('c:\\code\\topographic_analysis\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'c:\\code\\topographic_analysis\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_mainstem_110.tree')
#m_values_over_hillshade('c:\\code\\topographic_analysis\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'c:\\code\\topographic_analysis\\LSDRaster_chi_package\\Apennines\\rio_torto_fullProfileMC_forced_0.6_20_1_12_100_110.tree')
#coloured_chans_like_graphs('c:\\code\\topographic_analysis\\LSDRaster_chi_package\\Test_data\\rio_torto_HS.flt', 'c:\\code\\topographic_analysis\\LSDRaster_chi_package\\Test_data\\rio_torto_fullProfileMC_colinear_633.tree')